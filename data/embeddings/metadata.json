[
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 0,
    "text": "Software Engineering Tutorial Simply Easy Learning About the tutorial Software Engineering Tutorial This tutorial provide s you the basic understanding of software product, software design and development process, software project management and design complexities . At the end of the tutorial you should be equipped with well understanding of software engineering concepts. Audience This tutor ial is designed for the readers pursuing education in software development domain and all enthusiastic readers. Prerequisites This tutorial is designed and developed for absolute beginners. Though, awareness about software systems, software development pro cess and computer fundamentals would be beneficial. Copyright & Disclaimer  Copyright 2014 by Tutorials Point (I) Pvt. Ltd. All the content and graphics published in this e -book are the property of Tutotorials Point (I) Pvt. Ltd. The user of this e -book is prohibited to reuse, retain, copy, distribute or republish any contents or a part of co"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 1,
    "text": "................................ ................................ ................................ ......... 10 SOFTWARE DEVELOPMENT PARADIGM ................................ ................................ ................................ ...... 10 Waterfall Model ................................ ................................ ................................ ............................ 10 Iterative Model ................................ ................................ ................................ .............................. 11 Spiral Model ................................ ................................ ................................ ................................ .. 12 V – model ................................ ................................ ................................ ................................ ...... 12 Big Bang Mo del ................................ ................................ ................................ ............................. 14 SO"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 2,
    "text": "DESIGN LEVELS ................................ ................................ ................................ ...................... 36 MODULARIZATION ................................ ................................ ................................ ................................ . 37 CONCURRENCY ................................ ................................ ................................ ................................ ...... 37 Example ................................ ................................ ................................ ................................ ......... 37 COUPLING AND COHESION ................................ ................................ ................................ ...................... 38 COHESION ................................ ................................ ................................ ................................ ............ 38 COUPLING ................................ ................................ ......................."
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 3,
    "text": "71 External Inquiry ................................ ................................ ................................ ............................. 71 SOFTWARE IMPLEMENTAT ION ................................ ................................ ................................ ... 74 STRUCTURED PROGRAMMING ................................ ................................ ................................ ................. 74 FUNCTIONAL PROGRAMMING ................................ ................................ ................................ .................. 75 PROGRAMMING STYLE ................................ ................................ ................................ ............................ 76 Coding Guidelines ................................ ................................ ................................ .......................... 76 SOFTWARE DOCUMENTATION ................................ ................................ ................................ ............"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 4,
    "text": "for. The term is made of two words, software and engineering. Software is more than just a program code. A program is an executable code, which serves some computational purpose. Software is considered to be collection of executable programming code, associated libraries and documentations. Software, when made for a specific requirement is called softw are product. Engineering on the other hand, is all about developing products, using well - defined, scientific principles and methods. Software engineering is an engineering branch associated with development of software product using well -defined scientif ic principles , methods and procedures. The outcome of software engineering is an efficient and reliable software product. Definitions IEEE defines software engineering as: Software Overview 1 Software Engineering Tutorial 2 (1) The application of a systematic, disciplined, quantifiable approach to the devel opment, operation, and maintenance of software; that is, the application of e"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 5,
    "text": "with a collection of procedures. This is defined by exactly what procedures can do. In this software, the specifications can be described but the solution is not obviously instant. For example, gaming software. 3. Embedded -type (E -type) - This software works closely as the requirement of real -world environment. This software has a high degree of evolution as there are various changes in laws, taxes etc. in the real world situations. For example, Online trading software. E-Type software evolution Lehman has given eight laws for E -Type software evolution - 1. Continuing change - An E-type software system must continue to adapt to the real world changes, else it becomes progressively less useful. 2. Increasing complexity - As an E -type software system evolves, its complexity tends to increase unless work is done to maintain or reduce it. 3. Conservation of familiarity - The familiarity with the software or the knowledge about how it was developed, why was it developed in that particu"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 6,
    "text": "–  Design  Maintenance  Programming Programming Paradigm This paradigm is related closely to programming aspect of software development. This includes –  Coding  Testing  Integration Need of Software Engineering The need of software engineering arises because of higher rat e of change in user requirements and environment on which the software is working. Following are some of the needs stated:  Large software - It is easier to build a wall than a house or building, likewise, as the size of the software becomes large, engineer ing has to step to give it a scientific process.  Scalability - If the software process were not based on scientific and engineering concepts, it would be easier to re -create new software than to scale an existing one.  Cost- As hardware industry has shown its skills and huge manufacturing has lower down the price of computer and electronic hardware. But, cost of the software remains high if proper process is not adapted.  Dynamic Nature - Always growin"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 7,
    "text": "the following steps: Communication This is the first step where the user initiates the request for a desired software product. The user contacts the service provider and tries to negotiate the terms, submits the request to the service providing organization in writing. Requirement Gathering This step onwards the software development team works to carry on the project. The team holds discussions with various stakeholders from problem domain and tries to bring out as much information as possible on their requirements. The requirements are contemplated and segregated into user requirements, system requirements and functional requirements. The requirements are collected using a number of practices as given - Software Development Life Cycle 2 Software Engineering Tutorial 9  studying the existing or obsolete system and software,  conducting interviews of users and developers,  referring to the database or  collecting answers from the questionnaires. Feasibility Study After requirement g"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 8,
    "text": "conducted by testing experts at various levels of code such a s module testing, Software Engineering Tutorial 10 program testing, product testing, in -house testing, and testing the product at user’s end. Early discovery of errors and their remedy is the key to reliable software. Integration Software may need to be integrated with the libraries, databases, and other program(s). This stage of SDLC is involved in the integration of software with outer world entities. Implementation This means installing the software on user machines. At times, software needs post-installation configurations at user end. Software is tested for portability and adaptability and integration related issues are solved during implementation. Operation and Maintenance This phase confirms the software operation in terms of more efficiency and less errors. If required, the use rs are trained on, or aided with the documentation on how to operate the software and how to keep the software operational. The software is"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 9,
    "text": "produces a software, which is complete in itself and has more features and capabilities than that of the previous one. After each iteration, the management team can do work on risk management and prepare for the next iteration. Because a cycle include s small portion of whole Software Engineering Tutorial 12 software process, it is easier to manage the development process but it consumes more resources. Spiral Model Spiral model is a combination of both, iterative model and one of the SDLC model. It can be seen as if you choose one SDL C model and combined it with cyclic process (iterative model). This model considers risk, which often goes un -noticed by most other models. The model starts with determining objectives and constraints of the software at the start of one iteration. Next p hase is of prototyping the software. This includes risk analysis. Then one standard SDLC model is used to build the software. In the fourth phase of the plan of next iteration is prepared. V – model The"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 10,
    "text": "engaged in software development can be seen split in two parts:  Software Creation  Software Project Management A project is well -defined task, which is a collection of several operations done in order to achieve a goal (for example, software development and delivery). A Project can be characterized as:  Every project may have a unique and distinct goal.  Project is not a routine activity or day -to-day operation.  Project comes with a start and end time.  Project ends when its goal is ach ieved. Hence, it is a temporary phase in the lifetime of an organization.  Project needs adequate resources in terms of time, manpower, finance, material, and knowledge -bank. Software Project A Software Project is the complete procedure of software developm ent from requirement gathering to testing and maintenance, carried out according to the execution methodologies, in a specified period of time to achieve intended software product. Need of software project management Software is said to b"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 11,
    "text": " Act as pr oject leader  Lesion with stakeholders  Managing human resources  Setting up reporting hierarchy etc. Software Engineering Tutorial 17 Managing Project  Defining and setting up project scope  Managing project management activities  Monitoring progress and performance  Risk analysis at every phase  Take necessary step to avoid or come out of problems  Act as project spokesperson Software Management Activities Software project management comprises of a number of activities, which contains planning of project, deciding scope of software product, e stimation of cost in various terms, scheduling of tasks and events, and resource management. Project management activities may include:  Project Planning  Scope Management  Project Estimation Project Planning Software project planning is task, which is perfor med before the production of software actually starts. It is there for the software production but involves no concrete activity that has any direct connection with "
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 12,
    "text": "to produce the software can be estimated. Efforts required is segregated into sub categories as per the requirement specifications an d interdependency of various components of software. Software tasks are divided into smaller tasks, activities or events by Work Breakthrough Structure (WBS). The tasks are scheduled on day -to-day basis or in calendar months. The sum of time required to co mplete all tasks in hours or days is the total time invested to complete the project.  Cost estimation Software Engineering Tutorial 19 This might be considered as the most difficult of all because it depends on more elements than any of the previous ones. For estimating project cost, it is required to consider -  Size of the software  Software quality  Hardware  Additional software or tools, licenses etc.  Skilled personnel with task -specific skills  Travel involved  Communication  Training and support Project Estimation Techniques We discussed va rious parameters involving project estimati"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 13,
    "text": "for each task  Divide time into work -units  Assign adequate number of work -units for each task  Calculate total time required for the project from start to finish Resource management All elements used to develop a software product may be assumed as resource for that project. This may include human resource, productive tools , and software libraries . The resources are available in limited quantity and stay in the organization as a pool of assets. The shortage of resources hampers development of the project and it can lag behind the schedule. Allocating extra resources increases development cost in the end. It is therefore necessary to estimate and allocate adequate resources for the project. Resource management includes -  Defining proper organization project by creating a project team and allocating responsibilities to each team member  Determining resources required at a particular stage and their availability Software Engineering Tutorial 21  Manage Resources by generating r"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 14,
    "text": "given time frame, generally a week. Status can be marked as finished, pending or work -in-progress etc.  Milestones Checklist - Every project is divided into multiple phases where major tasks are performed (milestones) based on the phases of SDLC. This milestone checklist is prepared once every few weeks and re ports the status of milestones. Project Communication Management Effective communication plays vital role in the success of a project. It bridges gaps between client and the organization, among the team members as well as other stake holders in the project such as hardware suppliers. Communication can be oral or written. Communication management process may have the following steps:  Planning - This step includes the identifications of all the stakeholders in the project and the mode of communication among t hem. It also considers if any additional communication facilities are required.  Sharing - After determining various aspects of planning, manager focuses on sharing corre"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 15,
    "text": "administration, which takes care of occurrence of any change s (process, requirement, technological, strategical etc.) after a phase is baselined. CM keeps check on any changes done in software. Change Control Change control is function of configuration management, which ensures that all changes made to software system are consistent and made as per organi zational rules and regulations. A change in the configuration of product goes through following steps -  Identification - A change request arrives from either internal or external source. When change request is identified formally, it is properly documented .  Validation - Validity of the change request is checked and its handling procedure is confirmed.  Analysis - The impact of change request is analyzed in terms of schedule, cost and required efforts. Overall impact of the prospective change on system is ana lyzed. Software Engineering Tutorial 24  Control - If the prospective change either impacts too many entities in the sys"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 16,
    "text": "staff planning and coordination. Software Engineering Tutorial 26 Critical Path Analysis This tools is useful in recognizing interdependent tasks in the project. It also helps to find out the shortest path or critical path to complete the project successfully. Like PERT diagram, each event is allotted a specific time frame. This tool shows dependency of event assuming an event can proceed to next only if the previous one is completed. The events are arr anged according to their earliest possible start time. Path between start and end node is critical path which cannot be further reduced and all events require to be executed in same order. Software Engineering Tutorial 91 The software requirem ents are description of features and functionalities of the target system. Requirements convey the expectations of users from the software product. The requirements can be obvious or hidden, known or unknown, expected or unexpected from client’s point of v iew. Requirement Engineering The process "
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 17,
    "text": "from various stakeholders. SRS defines how the intended software will interact with hardware, external interfaces, speed of operation, response time of system, portability of software across various platforms, maintainability, speed of recovery after crashing, Security, Quality, Limitations etc. The requirements received from client are w ritten in natural language. It is the responsibility of the system analyst to document the requirements in technical language so that they can be comprehended and used by the software development team. SRS should come up with the following features:  User R equirements are expressed in natural language.  Technical requirements are expressed in structured language, which is used inside the organization.  Design description should be written in Pseudo code.  Format of Forms and GUI screen prints.  Conditional and m athematical notations for DFDs etc. Software Requirement Validation After requirement specifications are developed, the requirements me"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 18,
    "text": "follow pattern and matter of discussion firmly.  Non-structured (open) interviews, where information to gather is not decided in advance, more flexible and less biased.  Oral interviews  Written interviews  One-to-one interviews which are held between two persons across the table.  Group interviews which are held between groups of participants. They help to uncover any missing requirement as numerous people are involved. Surveys Organization may conduct surve ys among various stakeholders by querying about their expectation and requirements from the upcoming system. Questionnaires A document with pre -defined set of objective questions and respective options is handed over to all stakeholders to answer, which are collected and compiled. A shortcoming of this technique is, if an option for some issue is not mentioned in the questionnaire, the issue might be left unattended. Task analysis Team of engineers and developers may analyze the operation for which the ne w system is require"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 19,
    "text": "be categorized in two categories: Functional Requirements Requirements, which are related to functional aspect of software fall into this catego ry. They define functions and functionality within and from the software system. EXAMPLES -  Search option given to user to search from various invoices.  User should be able to mail any report to management.  Users can be divided into groups and groups can b e given separate rights.  Should comply business rules and administrative functions.  Software is developed keeping downward compatibility intact. Non-Functional Requirements Requirements, which are not related to functional aspect of software, fall into thi s category. They are implicit or expected characteristics of software, which users make assumption of. Non-functional requirements include -  Security  Logging  Storage  Configuration  Performance  Cost  Interoperability  Flexibility  Disaster recovery  Accessibilit y Requirements are categorized logically as :  Must H"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 20,
    "text": "It is the responsib ility of analyst to make sure that the developed software meets the requirements of the client. System Analysts have the following responsibilities:  Analyzing and understanding requirements of intended software  Understanding how the project will contribute to the organization al objectives  Identify sources of requirement  Validation of requirement  Develop and implement requirement management plan  Documentation of business, technical, process , and product requiremen ts  Coordination with clients to prioritize requirements and remove ambiguity  Finalizing acceptance criteria with client and other stakeholders Software Metrics and Measures Software Measures can be understood as a process of quantifying and symbolizing various attributes and aspects of software. Software Metrics provide measures for various aspects of software process and software product. Software measures are fundamental requirement s of software engineering. They not only help to contro"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 21,
    "text": "used into implementation in programming languages . Software design is the first step in SDLC (Software Design Life Cycle), which moves the concentration from problem domain to solution domain. It tries to specify how to fulfill the requirements mentioned in SRS. Software Design Levels Software design yields three levels of results:  Architectural Design - The architectural design is the highest abstract version of the system. It identifies the software as a system with many components interacting with each other. At this level, the designers get the idea of proposed solution domain.  High -level Design - The high -level design breaks the ‘single entity - multiple component’ concept of architectural design into less -abstracted view of sub -systems and modules and depicts their interaction with each other. High -level design focuses on how the system along with all of its components can be implemented in forms of modules. It recognizes modular structure of each sub -system and their "
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 22,
    "text": "concurrency provides capability to the software to execute more than one part of code in parallel to each other. It is necessary for the programmers and designers to recognize those modules, which can be made parallel execution. Example The spell check feature in word processor is a module of software, which runs along side th e word processor itself. Software Engineering Tutorial 38 Coupling and Cohesion When a software program is modularized, its tasks are divided into several modules based on some characteristics. As we know, modules are set of instructions put together in order to achieve some tasks. They a re though, considered as a single entity but , may refer to each other to work together. There are measures by which the quality of a design of modules and their interaction among them can be measured. These measures are called coupling and cohesion. Cohesi on Cohesion is a measure that defines the degree of intra -dependability within elements of a module. The greater the cohes"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 23,
    "text": "module can directly access or modify or refer to the content of another module, it is called content level coupling.  Common coupling - When multiple modules have read and write access to some global data, it is called common or global coupling.  Cont rol coupling - Two modules are called control -coupled if one of them decides the function of the other module or changes its flow of execution.  Stamp coupling - When multiple modules share common data structure and work on different part of it, it is called stamp coupling.  Data coupling - Data coupling is when two modules interact with each other by means of passing data (as parameter). If a module passes data structure as parameter, then the receiving module should use all its components. Ideally, no coupling is considered to be the best. Design Verification The output of software design process is design documentation, pseudo codes, detailed logic diagrams, process diagrams, and detailed description of all functional or non -func"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 24,
    "text": "It does not contain any control or branch elements. Types of DFD Data Flow Diagrams are either Logical or Physical.  Logical DFD - This type of DFD concentrates on the system process, and flow of data in the system. For example in a banking software system, how data is moved between different entities.  Physical DFD - This type of DFD shows how the data flow is actually implemented in the system. It is more specific and close to the implementation. DFD Components DFD can represent source, destination, storage , and flow of data using the following set of components - 6 Software Analysis and Design Tools Software Engineering Tutorial 42  Entities - Entities are source s and destination s of information data. Entities are represented by rectangles with their respective names.  Process - Activities and action taken on the data are represented by Circle or Round -edged rectangles.  Data Storage - There are two variants of data storage - it can either be represented as a rectangle with"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 25,
    "text": "Library Modules are re -usable and invokable from any module. Software Engineering Tutorial 44  Condition - It is represented by small diamond at base of the module. It depicts that control module can select any of sub -routine based on some condition.  Jump - An arrow is shown pointing inside the module to depict that the control will jump in the middle of the sub -module.  Loop - A curved arrow represents loop in the module. All sub -modules covered by loop repeat execution of module. Software Engineering Tutorial 45  Data flow - A directed arrow with empty circle at the end represents data flow.  Control flow - A directed arrow with filled circle at the end represents control flow. HIPO D iagram Hierarchical Input Process Output ( HIPO) diagram is a combination of two organized method s to analyze the system and provide the means of documentation. HIPO model was developed by IBM in year 1970. HIPO diagram represents the hierarchy of modules i n the software system. Analyst uses"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 26,
    "text": "code it. The following are some tokens of structured programming : IF-THEN-ELSE, DO-WHILE-UNTIL Analyst uses the same variable and data name, which are stored in Data Dictionary, making it much simpler to write and understand the code. Example We take the same example of Customer Authentication in the online shopping environment. This procedure to authenticate customer can be written in Structur ed English as: Enter Customer_Name SEEK Customer_Name in Customer_Name_DB file IF Customer_Name found THEN Call procedure USER_PASSWORD_AUTHENTICATE () ELSE PRINT error message Call procedure NEW_CUSTOMER_REQUEST () ENDIF Software Engineering Tutorial 48 The code written in Structured English is more like day -to-day spoken English. It can not be implemented directly as a code of software. Structured English is independent of programming language. Pseudo -Code Pseudo code is written more close to programming language. It may be considered as augmented programming language, full of comments , an"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 27,
    "text": "N Y Y N N Y Y Opens Website Y N Y N Y N Y N Actions Check network cable X Check internet router X X X X Restart Web Browser X Contact Service provider X X X X X X Do no action Table : Decision Table – In-house Internet Troubleshooting Entity -Relationship Model Entity -Relationship model is a type of database model based on the notion of real world entities and relationship among them. We can map real world scenario onto ER database model. ER Model creates a set of entities with their attributes, a set of constraints and relation among them. Software Engineering Tutorial 51 ER Model is best used for the conceptual design of database. ER Model can be represented as follows :  Entity - An entity in ER Model is a real world being, which has some properties called attributes . Every attribute is defined by its corresponding set of values, called domain . For example, Consider a school database. Here, a student is an entity. Student has various attributes like nam e, id, age and class etc."
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 28,
    "text": "(Street / Area) + City + State Course ID = Course Number + Course Name + Course Level + Course Grades Data Elements Data elements consist of Name and descriptions of Data and Control Items, Internal or External data stores etc. with the following details:  Primary Name  Secondary Name (Alias)  Use-case (How and where to use) Software Engineering Tutorial 53  Content Description (Notation etc. )  Supplementary Information (preset values, constraints etc.) Data Store It stor es the information from where the data enters into the system and exists out of the system. The Data Store may include -  Files o Internal to software. o External to software but on the same machine. o External to software and system, located on different machine.  Tables o Naming convention o Indexing property Data Processing There are two types of Data Processing:  Logical: As user sees it  Physical: As software sees it Software Engineering Tutorial 91 Software design is a process to conceptualize the soft"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 29,
    "text": "divide and conquer methodology is used. This design mechanism divides the whole system into smaller functions, which provides means of abstraction by concealing the information and their operation. These functional modules can share information among themselves by means of information passing and using information available globally. Another characteristic of functions is that when a program calls a function, the function changes the state of the program, which sometimes is not accept able by other modules. Function oriented design works well where the system state does not matter and program/functions work on input rather than on a state. Design Process  The whole system is seen as how data flows in the system by means of data flow diag ram.  DFD depicts how functions change data and state of the entire system.  The entire system is logically broken down into smaller units known as functions on the basis of their operation in the system.  Each function is then described at large. "
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 30,
    "text": "can be assigned same name. This is called polymorphism, w hich allows a single interface performing tasks for different types. Depending upon how the function is invoked, respective portion of the code gets executed. Design Process Software design process can be perceived as series of well -defined steps. Though it varies according to design approach (function oriented or object oriented, yet It may have the following steps involved:  A solution design is created from requirement or previous used system and/or system sequence diagram.  Objects are identified and grou ped into classes on behalf of similarity in attribute characteristics.  Class hierarchy and relation among them is defined.  Application framework is defined. Software Engineering Tutorial 57 Software Design Approaches Here are two generic approaches for software designing: Top Down Design We know that a system is composed of more than one sub -systems and it contains a number of components. Further, these sub -systems"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 31,
    "text": "music players, airplanes, ships etc. User interface is part of software and is designed in such a way that it i s expected to provide the user insight of the software. UI provides fundamental platform for human -computer interaction. UI can be graphical, text -based, audio -video based, depending upon the underlying hardware and software combination. UI can be hardware or software or a combination of both. The software becomes more popular if its user interface is:  Attractive  Simple to use  Responsive in short time  Clear to understand  Consistent on all interfacing screens UI is broadly divided into two categories:  Command Line Interface  Graphical User Interface Command Line Interface (CLI) CLI has been a great tool of interaction with computers until the video display monitors came into existence. CLI is first choice of many technical users and programmers. It is the minimum interface a software can provide to its users. CLI provides a command prompt, the place where the u"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 32,
    "text": "components to interact with software or hardware. Every graphical component provides a way to work with the system. A GUI system has following elements such as: Window - An area where contents of application are displayed. Contents in a window can be displayed in the form of icons or lists, if the window represents file structure. It is easier for a user to navigate in the file system in an exploring window. Windows can be minimized, resized or maximized to the size of screen. They can be moved anywhere on the screen. A window may contain another window of the same application, called child window.  Tabs - If an application allows executing multiple instances of itself, th ey appear on the screen as separate windows. Tabbed Document Interface has come up to open multiple documents in the same window. This interface Software Engineering Tutorial 61 also helps in viewing preference panel in application. All modern web - browsers use this feature.  Menu - Menu is an array of standard co"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 33,
    "text": "by check boxes can be selected.  List-box - Provides list of available items for selection. More than one item can be selected. Other impressive GUI components are:  Sliders  Combo -box  Data-grid  Drop-down list User Interface Design Activities There are a number of activities performed for designing user interface. The process of GUI design and implementation is alike SDLC. Any model can be used for GUI implementation among Waterfall, Iterative or Spiral Model. Software Engineering Tutorial 63 A model used for GUI design and development should fulfill these GUI specific steps.  GUI Requirement Gathering - The designers may like to have list of all functional and non -functional requirements of GUI. Thi s can be taken from user and their existing software solution.  User Analysis - The designer studies who is going to use the software GUI. The target audience matters as the design details change according to the knowledge and competency level of the user. If user is technical s"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 34,
    "text": "the golden rules for GUI design, described by Shneiderman and Plaisant in their book (Designin g the User Interface).  Strive for consistency - Consistent sequences of actions should be required in similar situations. Identical terminology should be used in prompts, menus, and help screens. Consistent commands should be employed throughout.  Enable fr equent users to use short -cuts - The user’s desire to reduce the number of interactions increases with the frequency of use. Abbreviations, function keys, hidden commands, and macro facilities are very helpful to an expert user. Software Engineering Tutorial 65  Offer informative feedback - For every operator action, there should be some system feedback. For frequent and minor actions, the response must be modest, while for infrequent and major actions, the response must be more substantial.  Design dialog to yield closure - Sequences of actions should be organized into groups with a beginning, middle, and end. The informative feedba"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 35,
    "text": "without using complexity metrics and measures. Let us see three important software complexity measures. Halstead's Complexity Measures In 1977, Mr. Mauri ce Howard Halstead introduced metrics to measure software complexity. Halstead’s metrics depends upon the actual implementation of program and its measures, which are computed directly from the operators and operands from source code, in static manner. It allows to evaluate testing time, vocabulary, size, difficulty, errors, and efforts for C/C++/Java source code. According to Halstead, “A computer program is an implementation of an algorithm considered to be a collection of tokens which can be classified a s either operators or operands”. Halstead metrics think a program as sequence of operators and their associated operands. He defines various indicators to check complexity of module. Following table states the parameters and the meanings: 9 Software Design Complexity Software Engineering Tutorial 68 Parameter Meaning n1 Number of u"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 36,
    "text": "- 8 + 2 Software Engineering Tutorial 70 = 4 According to P. Jorgensen, Cyclomatic Complexity of a module should not exceed 10. Function Point It is widely used to measure the size of software. Function Point concentrates on functionality provided by the system. Features and functionality of the system are used to m easure the software complexity. Function point counts on five parameters, named as External Input, External Output, Logical Internal Files, External Interface Files, and External Inquiry. To consider the complexity of software each parameter is further cat egorized as simple, average or complex. Let us see parameters of function point: External Input Every unique input to the system, from outside, is considered as external input. Uniqueness of input is measured, as no two inputs should have same formats. These inputs can either be data or control parameters.  Simple - if input count is low and affects less internal files  Complex - if input count is high and affects more "
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 37,
    "text": " Complex - if query needs high process and yields large amount of outpu t data Software Engineering Tutorial 72  Average - in between simple and complex. Each of these parameters in the system is given weightage according to their class and complexity. The table below mentions the weightage given to each parameter: Parameter Simple Average Complex Inputs 3 4 6 Outputs 4 5 7 Enquiry 3 4 6 Files 7 10 15 Interfaces 5 7 10 The table above yields raw Function Points. These function points are adjusted according to the environment complexity. System is described using fourteen different characteristics:  Data communications  Distributed processing  Performance objectives  Operation configuration load  Transaction rate  Online data entry,  End user efficiency  Online update  Complex processing logic  Re-usability  Installation ease  Operational ease  Multiple sites  Desire to facilitate changes These characteristics factors are then rated from 0 to 5, as mentioned below:  No "
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 38,
    "text": "where each one has some significance. Each problem is individually solved and steps are clearly stated about how to solve the problem. 2. Modular Programming - While programming, the code is broken down into smaller group of instructions. These groups are known as modules, subprograms, or subroutines. Modular programming based on the understanding of top -down analysis. It discourages jumps using ‘goto’ statements in the program, which often makes the program flow non - traceable. Jumps are prohibited and modular forma t is encouraged in structured programming. 3. Structured Coding - In reference with top -down analysis, structured coding sub -divides the modules into further smaller units of code in the 10 Software Implementation Software Engineering Tutorial 75 order of their execution. Structured programming uses control structure, which controls the flow of the program, whereas structured coding uses control structure to organize its instructions in definable patterns. Functional P"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 39,
    "text": "before invoki ng the function. Non -strict evaluation does not evaluate the expression unless it is needed.  λ-calculus - Most functional programming languages use λ -calculus as their type systems. λ -expressions are executed by evaluating them as they occur. Software Engineering Tutorial 76 Common Lisp, Scala, Haskell, Erlang, and F# are some examples of functional programming languages. Programming style Programming style is set of coding rules followed by all the programmers to write the code. When multiple programmers work on the same software project, they frequently need to work with the program code written by some other developer. This becomes tedious or at times impossible, if all developers do not follow some standard programming style to code the program. An appropriate programming style includes using function and variable names relevant to the intended task, using well -placed indentation, commenting code for the convenience of reader and overall presentation of code. Th"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 40,
    "text": "necessary to know about software process. Software documentation also provides information about how to use the product. A well -maintained documentation should involve the following documents:  Requirement documentation - This documentation works as key tool for software designer, developer, and the test team to carry out their respective tasks. This document contains all the functional, non -functional and behavioral description of the intended software. Source of this document can be previously stored data about the software, already running software at the client’s end, client’s interview, questionnaires, and research. Generally it is stored in the form of spreadsheet or word processing document with the high -end software management team. This documentation works as foundation for the software to be developed and is majorly used in verification and validation phases. Most test -cases are built directly from requirement documentation.  Software Design documentation - These docume"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 41,
    "text": "to bring the cost down of end product, the organization management prefers to re -use the code, which was created earlier for some other software. There are huge issues faced by programmers for compatibility checks and deciding how much code to re -use.  Version Management - Every time a new software is issued to the customer, developers have to maintain version and configuration related documentation. This documentation needs to be highly accurate and available on time.  Target -Host - The software program, which is being developed in the organization, needs to be designed for host machines at the customers end. Software Engineering Tutorial 79 But at times, it is impossible to design a software that works on the target machines. Software Engineering Tutorial 91 Software Testing is evaluation of the software against requirements gathered from users and system specifications. Testing is conducted at the ph ase level in software development life cycle or at module level in program cod"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 42,
    "text": "levels of the code, executes the tests and reports the result to the manager. Manual testing is time and resource consuming. The tester needs to confirm whether or not right test cases are used. Major portion of testing involves manual testing.  Automated This testing is a testing procedure done with aid of automated testing tools. The limitations with manual testing can be overcome using automated test tools. A test needs to check if a webpage can be opened in Internet Explorer. This can be easily done with manual testing. But to check if the web -server can take the load of 1 million users, it is quite impossible to test manually. There are software and hardware tools which helps tester in conducting load testing, stress testing, regression testing. Testing Approaches Tests can be conducted based on two approaches – 1. Functionality testing 2. Implementation testing When functionality is being tested without taking the actual implementation in concern it is known as black -box testi"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 43,
    "text": "values.  State -based testing - The system changes state on provision of input. These systems are tested based on their states and input. White -box testing It is conducted to test program and its implementation, in order to improve code efficiency or structure. It is also known as ‘Structural’ testing. Software Engineering Tutorial 83 In this testing method, the design and structure of the code are known to the tester. Programmers of the code conduct this test on the code. The below are some White -box testing techniques:  Control -flow testing - The purpose of the control -flow testing to set up test cases which covers all statements and branch conditions. The branch conditions are tested for both being true and false, so that all statements can be covered.  Data -flow testing - This testing technique emphasis to cover all the data variables included in the program. It tests where the variables were declared and defined and where they were used or ch anged. Testing Levels Testing "
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 44,
    "text": "to the customer it has to go through last phase of testing where it is tested for user -interaction and response. This is important because even if the software matches all user requirements and if user does not like the way it appears or works, it may be rejected.  Alpha testing - The team of developer themselves perform alpha testing by using the system as if it is being used in work environment. They try to find out how user would react to some action in software and how the system should respond to inputs.  Beta testing - After the software is tested internally, it is handed over to the users to use it under their production environment only for t esting purpose. This is not as yet the delivered product. Developers expect that users at this stage will bring minute problems, which were skipped to attend. Regression Testing Whenever a software product is updated with new code, feature or functionality , it is tested thoroughly to detect if there is any negative impact of the added "
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 45,
    "text": "if it is ready to launch. Software Engineering Tutorial 86 Testing vs. Quality Control & Assurance and Audit We need to understand that software testing is different from software quality assurance, software quality control and software auditing.  Software quality assurance - These are software development process monitoring means, by which it is assured that all the measure s are taken as per the standards of organization. This monitoring is done to make sure that proper software development methods were followed.  Software quality control - This is a system to maintain the quality of software product. It may include functiona l and non -functional aspects of software product, which enhance the goodwill of the organization. This system makes sure that the customer is receiving quality product for their requirement and the product certified as ‘fit for use’.  Software a udit - This is a review of procedure used by the organization to develop the software. A team of auditors, indepen"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 46,
    "text": "keep the software product up -to date and tuned to the ever changing world of technology and business environment. 12 Software Maintenance Overview Software Engineering Tutorial 88  Perfect ive Maintenance - This includes modifications and updates done in order to keep the software usable over long period of time. It includes new features, new user requirements for refining the software and improve its reliability and performance.  Preventive Maintenance - This includes modifications and updations to prevent future problems of the software. It aims to attend problems, which are not significant at this moment but may cause serious issues in future. Cost of Maintenance Reports suggest that the co st of maintenance is high. A study on estimating software maintenance found that the cost of maintenance is as high as 67% of the cost of entire software process cycle. On an average, the cost of software maintenance is more than 50% of all SDLC phases. There are various factors, which trigger"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 47,
    "text": "replaced or modified, are designed against requirement specifications set in the previous stage. Test cases are created for validation and verification.  Implementation - The new modules are coded with the help of structured design created in the design step.Every programmer is expected to do unit testing in parallel.  System Testing - Integration testing is done among newly created modules. Integration testing is also carried out between new modules and the system. Finally the system is tested as a whole, following regressive testing procedures.  Acceptance Testing - After testing the system internally, it is tested for acceptance with the help of users. If at this state, user complaints some issues they are addressed or noted to addre ss in next iteration.  Delivery - After acceptance test, the system is deployed all over the organization either by small update package or fresh installation of the system. The final testing takes place at client end after the software is delivered"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 48,
    "text": "abstraction level by analyzing lower abstra ction levels. An existing system is previously implemented design, about which we know nothing. Designers then do reverse engineering by looking at the code and try to get the design. With design in hand, they try to conclude the specifications. Thus, going in reverse from code to system specification. Program Restructuring It is a process to re -structure and re -construct the existing software. It is all about re-arranging the source code, either in same programming language or from one programming la nguage to a different one. Restructuring can have either source code-restructuring and data -restructuring or both. Re-structuring does not impact the functionality of the software but enhance reliability and maintainability. Program components, which cause errors very frequently can be changed, or updated with re -structuring. The dependability of software on obsolete hardware platform can be removed via re-structuring. Forward Engineering Fo"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 49,
    "text": " Requirement Specification - The functional and non -functional requirements are s pecified, which a software product must comply to, with the help of existing system, user input or both.  Design - This is also a standard SDLC process step, where requirements are defined in terms of software parlance. Basic architecture of system as a who le and its sub -systems are created.  Specify Components - By studying the software design, the designers segregate the entire system into smaller components or sub -systems. One complete software design turns into a collection of a huge set of components wor king together.  Search Suitable Components - The software component repository is referred by designers to search for the matching component, on the basis of functionality and intended software requirements..  Incorporate Components - All matched components are packed together to shape them as complete software. Software Engineering Tutorial 100 CASE stands for Computer Aided Software Engine"
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 50,
    "text": "CASE tools Diagram tools These tools are used to represent system components , data and control flow among various software components and system structure in a graphical form. For example, Flow Chart Maker tool for creating state -of-the-art flowcharts. Process Modeling Tools Process modeling is method to create software process mo del, which is used to develop the software. Process modeling tools help the managers to choose a process model or modify it as per the requirement of software product. For example, EPF Composer Software Engineering Tutorial 102 Project Management Tools These tools are used for project plan ning, cost and effort estimation, project scheduling and resource planning. Managers have to strictly comply project execution with every mentioned step in software project management. Project management tools help in storing and sharing project informatio n in real -time throughout the organization. For example, Creative Pro Office, Trac Project, Basecamp. Documentation "
  },
  {
    "source": "data/knowledge_base\\SE_Notes.pdf",
    "chunk_index": 51,
    "text": "building software product and include features for simulation and testing. For example, Cscope to search code in C, Eclipse. Prototyping Tools Software prototype i s simulated version of the intended software product. Prototype provides initial look and feel of the product and simulates few aspect of actual product. Prototyping CASE tools essentially come with graphical libraries. They can create hardware independent user interfaces and design. These tools help us to build rapid prototypes based on existing information. In addition, they provide simulation of software prototype. For example, Serena prototype composer, Mockup Builder. Web Development Tools These tools assist in designing web pages with all allied elements like forms, text, script, graphic and so on. Web tools also provide live preview of what is being developed and how will it look after completion. For example, Fontello, Adobe Edge Inspect, Foundation 3, Brackets. Quality Assurance Tools Quality assurance in a software"
  }
]